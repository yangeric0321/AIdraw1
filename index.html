<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIç®€ç¬”ç”»è¯†åˆ« - ä¸­å°å­¦AIæ•™è‚²</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #72EDF2 0%, #5151E5 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            padding: 30px;
        }

        /* æ•™å­¦å¼•å¯¼åŒºæ ·å¼ */
        .teaching-section {
            background: #f0f8ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 5px solid #5151E5;
        }

        .teaching-section h2 {
            color: #5151E5;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .teaching-section p {
            font-size: 14px;
            line-height: 1.6;
            color: #555;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
            font-weight: bold;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        /* é€‚é…ç§»åŠ¨ç«¯ */
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            h1 {
                font-size: 1.6em;
            }
        }

        .draw-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #canvas {
            border: 3px solid #5151E5;
            border-radius: 10px;
            cursor: crosshair;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 100%;
            height: auto;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-primary {
            background: #5151E5;
            color: white;
        }

        .btn-primary:hover {
            background: #4040c9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: #FF9D76;
            color: white;
        }

        .btn-secondary:hover {
            background: #ff8a5f;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #FF6B6B;
            color: white;
        }

        .btn-danger:hover {
            background: #ee5a52;
        }

        .results-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .results-section h2 {
            margin-bottom: 15px;
            color: #5151E5;
            font-size: 1.4em;
        }

        .prediction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .prediction-label {
            font-weight: 600;
            color: #333;
            width: 80px;
        }

        .prediction-bar {
            flex-grow: 1;
            margin: 0 15px;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .prediction-fill {
            height: 100%;
            background: linear-gradient(90deg, #72EDF2, #5151E5);
            transition: width 0.3s;
        }

        .prediction-confidence {
            font-weight: 600;
            color: #5151E5;
            width: 60px;
            text-align: right;
        }

        /* åé¦ˆåŒºåŸŸæ ·å¼ */
        .feedback-section {
            margin-top: 20px;
            padding: 15px;
            background: #fff8e1;
            border-radius: 8px;
            border-left: 4px solid #FFC107;
            display: none;
        }

        .feedback-section h3 {
            color: #FF8F00;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .feedback-section p {
            margin-bottom: 10px;
            font-size: 14px;
        }

        .feedback-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #wrong-label {
            display: none;
            margin-top: 10px;
        }

        #correct-label {
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
            width: 200px;
        }

        /* æ ‡ç­¾é¡µæ ·å¼ */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
            flex-wrap: wrap;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab.active {
            color: #5151E5;
            border-bottom-color: #5151E5;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* å†å²è®°å½•æ ·å¼ */
        .history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-height: 500px;
            overflow-y: auto;
            padding: 10px 0;
        }

        .history-item {
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .history-item:hover {
            border-color: #5151E5;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .history-canvas {
            width: 100%;
            height: 120px;
            border-radius: 4px;
            object-fit: contain;
            background: #f8f9fa;
        }

        .history-label {
            margin-top: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        /* å¯¼å…¥æ•°æ®é›†æ ·å¼ */
        .import-section {
            padding: 20px;
            background: #e8f4f8;
            border-radius: 8px;
            margin-top: 20px;
        }

        .import-section h2 {
            color: #5151E5;
            margin-bottom: 10px;
            font-size: 1.4em;
        }

        .import-section p {
            margin-bottom: 15px;
            line-height: 1.6;
            font-size: 14px;
        }

        input[type="file"] {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 10px 20px;
            background: #5151E5;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .file-label:hover {
            background: #4040c9;
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            display: none;
            font-size: 14px;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            display: block;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            display: block;
        }

        #categories-list {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        #categories-list span {
            background: #5151E5;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ AIç®€ç¬”ç”»è¯†åˆ« - ä¸­å°å­¦AIæ•™è‚²è¯¾å ‚</h1>

        <!-- æ•™å­¦å¼•å¯¼åŒºåŸŸ -->
        <div class="teaching-section">
            <h2>ğŸ¤– AIå­¦ä¹ å°è¯¾å ‚</h2>
            <p>AIå°±åƒå°æœ‹å‹ä¸€æ ·ï¼Œéœ€è¦é€šè¿‡"å­¦ä¹ "å¤§é‡æ•°æ®æ‰èƒ½è®¤è¯†äº‹ç‰©ï¼ä½ ç”»çš„æ¯ä¸€å¹…ç”»ã€ç»™å‡ºçš„æ¯ä¸€æ¬¡åé¦ˆï¼Œéƒ½ä¼šæˆä¸ºAIçš„å­¦ä¹ èµ„æ–™ã€‚å¯¼å…¥ä¸“ä¸šçš„Quick Drawæ•°æ®é›†ï¼Œèƒ½è®©AIè®¤è¯†æ›´å¤šå›¾æ¡ˆå“¦ï½</p>
        </div>

        <!-- åŠŸèƒ½æ ‡ç­¾é¡µ -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('draw')">ç»˜ç”»è¯†åˆ«</button>
            <button class="tab" onclick="switchTab('history')">æˆ‘çš„ç»˜ç”»è®°å½•</button>
            <button class="tab" onclick="switchTab('import')">å¯¼å…¥å­¦ä¹ æ•°æ®</button>
        </div>

        <!-- ç»˜ç”»è¯†åˆ«æ ‡ç­¾é¡µ -->
        <div id="draw-tab" class="tab-content active">
            <div class="main-content">
                <div class="draw-section">
                    <canvas id="canvas" width="400" height="400"></canvas>
                    <div class="controls">
                        <button class="btn-danger" onclick="clearCanvas()">æ¸…ç©ºç”»å¸ƒ</button>
                        <button class="btn-primary" onclick="recognize()">è®©AIçŒœçŒœ</button>
                        <button class="btn-secondary" onclick="saveDrawing()">ä¿å­˜æˆ‘çš„ç”»</button>
                    </div>
                </div>

                <div class="results-section">
                    <h2>AIè¯†åˆ«ç»“æœ</h2>
                    <div id="predictions"></div>
                    
                    <div class="feedback-section" id="feedback-section">
                        <h3>AIçŒœå¯¹äº†å—ï¼Ÿ</h3>
                        <p>ä½ çš„åé¦ˆèƒ½å¸®åŠ©AIå˜å¾—æ›´èªæ˜å“¦ï¼</p>
                        <div class="feedback-buttons">
                            <button class="btn-primary" onclick="provideFeedback(true)">âœ“ çŒœå¯¹äº†</button>
                            <button class="btn-danger" onclick="provideFeedback(false)">âœ— çŒœé”™äº†</button>
                        </div>
                        <div id="wrong-label">
                            <label>æ­£ç¡®çš„ç­”æ¡ˆæ˜¯ï¼š</label>
                            <input type="text" id="correct-label" placeholder="æ¯”å¦‚ï¼šè‹¹æœã€å°çŒ«ã€æ˜Ÿæ˜Ÿ">
                            <button class="btn-primary" onclick="submitCorrection()">å‘Šè¯‰AI</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å†å²è®°å½•æ ‡ç­¾é¡µ -->
        <div id="history-tab" class="tab-content">
            <h2>æˆ‘çš„ç»˜ç”»è®°å½•</h2>
            <p style="margin-bottom: 15px; color: #666;">ç‚¹å‡»è®°å½•å¯ä»¥é‡æ–°æŸ¥çœ‹ä½ çš„ç”»ä½œï½</p>
            <div class="controls">
                <button class="btn-danger" onclick="clearHistory()">æ¸…ç©ºæ‰€æœ‰è®°å½•</button>
                <button class="btn-secondary" onclick="exportHistory()">å¯¼å‡ºæˆ‘çš„ä½œå“</button>
            </div>
            <div class="history-grid" id="history-grid"></div>
        </div>

        <!-- å¯¼å…¥æ•°æ®é›†æ ‡ç­¾é¡µ -->
        <div id="import-tab" class="tab-content">
            <div class="import-section">
                <h2>ç»™AIå¯¼å…¥å­¦ä¹ èµ„æ–™</h2>
                <p>Quick Drawæ˜¯è°·æ­Œçš„ç®€ç¬”ç”»æ•°æ®é›†ï¼ŒåŒ…å«æ•°ç™¾ä¸‡å¹…ç®€ç¬”ç”»ã€‚å¯¼å…¥åAIèƒ½è®¤è¯†æ›´å¤šå›¾æ¡ˆï¼</p>
                <p>ğŸ“¥ æ•°æ®é›†ä¸‹è½½åœ°å€ï¼š<a href="https://github.com/googlecreativelab/quickdraw-dataset" target="_blank" style="color: #5151E5;">ç‚¹å‡»ä¸‹è½½</a>ï¼ˆé€‰æ‹©.ndjsonæ ¼å¼æ–‡ä»¶ï¼‰</p>
                
                <input type="file" id="dataset-file" accept=".ndjson,.json" onchange="importDataset(event)">
                <label for="dataset-file" class="file-label">é€‰æ‹©æ•°æ®é›†æ–‡ä»¶</label>
                
                <div id="import-status" class="status"></div>
                
                <div style="margin-top: 20px;">
                    <h3>AIå·²å­¦ä¼šçš„ç±»åˆ«ï¼š</h3>
                    <div id="categories-list"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡åˆå§‹åŒ–
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let currentStrokes = [];
        let currentStroke = [];
        
        // æœ¬åœ°å­˜å‚¨æ•°æ®ï¼ˆæŒä¹…åŒ–ä¿å­˜ï¼‰
        let drawingHistory = JSON.parse(localStorage.getItem('drawingHistory') || '[]');
        let trainingData = JSON.parse(localStorage.getItem('trainingData') || '{}');
        let lastPrediction = null;

        // ç”»å¸ƒåˆå§‹åŒ–
        ctx.lineWidth = 4; // åŠ ç²—ç”»ç¬”ï¼Œæ›´é€‚åˆå­¦ç”Ÿç»˜ç”»
        ctx.lineCap = 'round';
        ctx.strokeStyle = '#333';

        // é¼ æ ‡ç»˜ç”»äº‹ä»¶
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // è§¦æ‘¸æ”¯æŒï¼ˆå¹³æ¿/æ‰‹æœºï¼‰
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

        // å¼€å§‹ç»˜ç”»
        function startDrawing(e) {
            isDrawing = true;
            currentStroke = [];
            const rect = canvas.getBoundingClientRect();
            // é€‚é…ç”»å¸ƒç¼©æ”¾ï¼Œç¡®ä¿ç»˜ç”»åæ ‡æ­£ç¡®
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            currentStroke.push([x, y]);
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        // ç»˜ç”»ä¸­
        function draw(e) {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            currentStroke.push([x, y]);
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        // ç»“æŸç»˜ç”»
        function stopDrawing() {
            if (isDrawing && currentStroke.length > 0) {
                currentStrokes.push(currentStroke);
                currentStroke = [];
            }
            isDrawing = false;
        }

        // æ¸…ç©ºç”»å¸ƒ
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            currentStrokes = [];
            document.getElementById('predictions').innerHTML = '';
            document.getElementById('feedback-section').style.display = 'none';
            lastPrediction = null;
        }

        // è·å–ç”»å¸ƒå›¾ç‰‡æ•°æ®
        function getImageData() {
            return canvas.toDataURL();
        }

        // ç‰¹å¾æå–ï¼šåˆ†æç»˜ç”»çš„å½¢çŠ¶ã€å¯†åº¦ã€ç¬”ç”»æ•°ç­‰ç‰¹å¾
        function extractFeatures() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // è®¡ç®—åŸºç¡€ç‰¹å¾
            let totalPixels = 0;
            let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    if (data[i + 3] > 0) { // éé€æ˜åƒç´ ï¼ˆæœ‰ç¬”ç”»ï¼‰
                        totalPixels++;
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // å¤„ç†ç©ºç™½ç”»å¸ƒæƒ…å†µ
            const width = maxX - minX || 1;
            const height = maxY - minY || 1;
            const aspectRatio = width / height;
            const density = totalPixels / (canvas.width * canvas.height);
            const strokeCount = currentStrokes.length;
            
            return {
                aspectRatio,    // å®½é«˜æ¯”
                density,        // åƒç´ å¯†åº¦
                strokeCount,    // ç¬”ç”»æ•°
                width,          // å®½åº¦
                height,         // é«˜åº¦
                totalPixels     // æ€»åƒç´ æ•°
            };
        }

        // AIè¯†åˆ«æ ¸å¿ƒå‡½æ•°
        function recognize() {
            if (currentStrokes.length === 0) {
                alert('è¯·å…ˆåœ¨ç”»å¸ƒä¸Šç”»ä¸€å¹…ç®€ç¬”ç”»å§ï¼');
                return;
            }

            const features = extractFeatures();
            const predictions = [];

            // 1. å†…ç½®è§„åˆ™è¯†åˆ«ï¼ˆåŸºç¡€å½¢çŠ¶ï¼‰
            const builtInPredictions = recognizeBuiltIn(features);
            predictions.push(...builtInPredictions);

            // 2. åŸºäºç”¨æˆ·æ•°æ®/å¯¼å…¥æ•°æ®é›†çš„è¯†åˆ«
            const trainedPredictions = recognizeFromTrainingData(features);
            predictions.push(...trainedPredictions);

            // åˆå¹¶ç»“æœå¹¶æ’åºï¼ˆç½®ä¿¡åº¦ä»é«˜åˆ°ä½ï¼‰
            const mergedPredictions = mergePredictions(predictions);
            
            // æ˜¾ç¤ºè¯†åˆ«ç»“æœ
            displayPredictions(mergedPredictions);
            lastPrediction = mergedPredictions[0];
            document.getElementById('feedback-section').style.display = 'block';
        }

        // å†…ç½®è§„åˆ™è¯†åˆ«ï¼šè¯†åˆ«åŸºç¡€å½¢çŠ¶ï¼ˆé€‚åˆå°å­¦ç”Ÿè®¤çŸ¥ï¼‰
        function recognizeBuiltIn(features) {
            const predictions = [];
            const { aspectRatio, density, strokeCount, width, height } = features;

            // åœ†å½¢/çƒ
            if (aspectRatio > 0.8 && aspectRatio < 1.2 && strokeCount <= 2 && density < 0.15) {
                predictions.push({ label: 'åœ†å½¢/çƒ', confidence: 0.85 });
            }

            // æ­£æ–¹å½¢
            if (strokeCount <= 2 && density > 0.05 && density < 0.2 && aspectRatio > 0.8 && aspectRatio < 1.2) {
                predictions.push({ label: 'æ­£æ–¹å½¢', confidence: 0.8 });
            }

            // é•¿æ–¹å½¢
            if (strokeCount <= 2 && density > 0.05 && density < 0.2 && (aspectRatio < 0.8 || aspectRatio > 1.2)) {
                predictions.push({ label: 'é•¿æ–¹å½¢', confidence: 0.78 });
            }

            // ä¸‰è§’å½¢
            if (strokeCount <= 3 && density < 0.12) {
                predictions.push({ label: 'ä¸‰è§’å½¢', confidence: 0.75 });
            }

            // æ˜Ÿæ˜Ÿ
            if (strokeCount >= 3 && strokeCount <= 6 && density < 0.15) {
                predictions.push({ label: 'æ˜Ÿæ˜Ÿ', confidence: 0.7 });
            }

            // æˆ¿å­
            if (strokeCount >= 3 && aspectRatio > 0.7 && aspectRatio < 1.3) {
                predictions.push({ label: 'æˆ¿å­', confidence: 0.65 });
            }

            // èŠ±æœµ
            if (strokeCount >= 4 && density < 0.2) {
                predictions.push({ label: 'èŠ±æœµ', confidence: 0.6 });
            }

            // å¤ªé˜³
            if (strokeCount >= 8 && aspectRatio > 0.8 && aspectRatio < 1.2) {
                predictions.push({ label: 'å¤ªé˜³', confidence: 0.65 });
            }

            return predictions;
        }

        // åŸºäºè®­ç»ƒæ•°æ®çš„è¯†åˆ«ï¼ˆç”¨æˆ·åé¦ˆ/å¯¼å…¥çš„æ•°æ®é›†ï¼‰
        function recognizeFromTrainingData(features) {
            const predictions = [];
            
            // éå†æ‰€æœ‰è®­ç»ƒæ•°æ®ç±»åˆ«
            for (const [label, samples] of Object.entries(trainingData)) {
                if (samples.length === 0) continue;
                
                // è®¡ç®—å½“å‰ç»˜ç”»ä¸è®­ç»ƒæ ·æœ¬çš„ç›¸ä¼¼åº¦
                let similarity = 0;
                for (const sample of samples) {
                    similarity += calculateSimilarity(features, sample.features);
                }
                similarity /= samples.length; // å¹³å‡ç›¸ä¼¼åº¦
                
                // ç›¸ä¼¼åº¦å¤§äº0.3æ‰çº³å…¥ç»“æœ
                if (similarity > 0.3) {
                    predictions.push({ label, confidence: similarity });
                }
            }
            
            return predictions;
        }

        // è®¡ç®—ç‰¹å¾ç›¸ä¼¼åº¦
        function calculateSimilarity(features1, features2) {
            // è®¡ç®—å„ç‰¹å¾çš„å·®å¼‚ï¼ˆè¶Šå°è¶Šç›¸ä¼¼ï¼‰
            const aspectDiff = Math.abs(features1.aspectRatio - features2.aspectRatio);
            const densityDiff = Math.abs(features1.density - features2.density);
            const strokeDiff = Math.abs(features1.strokeCount - features2.strokeCount) / 10;
            
            // åŠ æƒè®¡ç®—ç›¸ä¼¼åº¦ï¼ˆ1 - æ€»å·®å¼‚ï¼‰
            const similarity = 1 - (aspectDiff * 0.3 + densityDiff * 0.4 + strokeDiff * 0.3);
            return Math.max(0, similarity); // ç¡®ä¿ç›¸ä¼¼åº¦éè´Ÿ
        }

        // åˆå¹¶é¢„æµ‹ç»“æœï¼ˆå»é‡å¹¶å–æœ€é«˜ç½®ä¿¡åº¦ï¼‰
        function mergePredictions(predictions) {
            const merged = {};
            
            // å»é‡ï¼Œä¿ç•™åŒä¸€æ ‡ç­¾çš„æœ€é«˜ç½®ä¿¡åº¦
            for (const pred of predictions) {
                if (merged[pred.label]) {
                    merged[pred.label] = Math.max(merged[pred.label], pred.confidence);
                } else {
                    merged[pred.label] = pred.confidence;
                }
            }
            
            // è½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰ç½®ä¿¡åº¦æ’åº
            return Object.entries(merged)
                .map(([label, confidence]) => ({ label, confidence }))
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, 5); // åªä¿ç•™å‰5ä¸ªç»“æœ
        }

        // æ˜¾ç¤ºè¯†åˆ«ç»“æœ
        function displayPredictions(predictions) {
            const container = document.getElementById('predictions');
            container.innerHTML = '';
            
            if (predictions.length === 0) {
                container.innerHTML = '<p>ğŸ˜¯ AIæš‚æ—¶ä¸è®¤è¯†è¿™ä¸ªå›¾æ¡ˆï¼Œè¯•è¯•ç»™AIåé¦ˆå¸®åŠ©å®ƒå­¦ä¹ å§ï¼</p>';
                return;
            }
            
            // æ¸²æŸ“æ¯ä¸ªé¢„æµ‹ç»“æœ
            predictions.forEach(pred => {
                const item = document.createElement('div');
                item.className = 'prediction-item';
                // æ ¼å¼åŒ–ç½®ä¿¡åº¦ä¸ºç™¾åˆ†æ¯”
                const confidencePercent = (pred.confidence * 100).toFixed(1);
                item.innerHTML = `
                    <span class="prediction-label">${pred.label}</span>
                    <div class="prediction-bar">
                        <div class="prediction-fill" style="width: ${confidencePercent}%"></div>
                    </div>
                    <span class="prediction-confidence">${confidencePercent}%</span>
                `;
                container.appendChild(item);
            });
        }

        // ä¿å­˜ç»˜ç”»è®°å½•
        function saveDrawing() {
            if (currentStrokes.length === 0) {
                alert('è¯·å…ˆç”»ä¸€å¹…ç”»å†ä¿å­˜å“¦ï¼');
                return;
            }

            const drawing = {
                id: Date.now(),
                imageData: getImageData(),
                strokes: JSON.parse(JSON.stringify(currentStrokes)), // æ·±æ‹·è´
                features: extractFeatures(),
                timestamp: new Date().toISOString(),
                prediction: lastPrediction ? lastPrediction.label : 'æœªè¯†åˆ«'
            };

            // æ·»åŠ åˆ°å†å²è®°å½•å¹¶ä¿å­˜åˆ°æœ¬åœ°
            drawingHistory.unshift(drawing);
            // é™åˆ¶å†å²è®°å½•æ•°é‡ï¼ˆæœ€å¤š50æ¡ï¼‰
            if (drawingHistory.length > 50) {
                drawingHistory.pop();
            }
            localStorage.setItem('drawingHistory', JSON.stringify(drawingHistory));
            
            alert('âœ… ä½ çš„ç”»ä½œå·²ç»ä¿å­˜æˆåŠŸï¼');
        }

        // å¤„ç†ç”¨æˆ·åé¦ˆ
        function provideFeedback(isCorrect) {
            if (!lastPrediction) {
                alert('è¯·å…ˆè®©AIè¯†åˆ«ä½ çš„ç”»ä½œï¼');
                return;
            }

            if (isCorrect) {
                // åé¦ˆæ­£ç¡®ï¼šå°†å½“å‰ç»˜ç”»åŠ å…¥å¯¹åº”ç±»åˆ«çš„è®­ç»ƒæ•°æ®
                addToTrainingData(lastPrediction.label, {
                    features: extractFeatures(),
                    strokes: JSON.parse(JSON.stringify(currentStrokes))
                });
                alert('ğŸ‰ å¤ªæ£’äº†ï¼AIè®°ä½äº†è¿™ä¸ªå›¾æ¡ˆï¼Œä»¥åä¼šæ›´å‡†ç¡®å“¦ï½');
                document.getElementById('feedback-section').style.display = 'none';
            } else {
                // åé¦ˆé”™è¯¯ï¼šæ˜¾ç¤ºè¾“å…¥æ­£ç¡®ç­”æ¡ˆçš„æ¡†
                document.getElementById('wrong-label').style.display = 'block';
            }
        }

        // æäº¤æ­£ç¡®æ ‡ç­¾ï¼ˆä¿®æ­£AIçš„é”™è¯¯ï¼‰
        function submitCorrection() {
            const correctLabel = document.getElementById('correct-label').value.trim();
            if (!correctLabel) {
                alert('è¯·è¾“å…¥æ­£ç¡®çš„å›¾æ¡ˆåç§°ï¼');
                return;
            }

            // å°†ç»˜ç”»åŠ å…¥æ­£ç¡®æ ‡ç­¾çš„è®­ç»ƒæ•°æ®
            addToTrainingData(correctLabel, {
                features: extractFeatures(),
                strokes: JSON.parse(JSON.stringify(currentStrokes))
            });

            alert(`âœ… è°¢è°¢ä½ çš„åé¦ˆï¼AIå·²ç»å­¦ä¼šäº†è¿™ä¸ªå›¾æ¡ˆæ˜¯"${correctLabel}"ï½`);
            // é‡ç½®åé¦ˆåŒºåŸŸ
            document.getElementById('feedback-section').style.display = 'none';
            document.getElementById('wrong-label').style.display = 'none';
            document.getElementById('correct-label').value = '';
        }

        // æ·»åŠ æ•°æ®åˆ°è®­ç»ƒé›†
        function addToTrainingData(label, data) {
            if (!trainingData[label]) {
                trainingData[label] = [];
            }
            trainingData[label].push(data);
            
            // æ¯ä¸ªç±»åˆ«æœ€å¤šä¿å­˜100ä¸ªæ ·æœ¬ï¼ˆé˜²æ­¢æ•°æ®è¿‡å¤šï¼‰
            if (trainingData[label].length > 100) {
                trainingData[label].shift();
            }
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            localStorage.setItem('trainingData', JSON.stringify(trainingData));
        }

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabName) {
            // ç§»é™¤æ‰€æœ‰æ¿€æ´»çŠ¶æ€
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // æ¿€æ´»å½“å‰æ ‡ç­¾
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');

            // æŒ‰éœ€åŠ è½½å†…å®¹
            if (tabName === 'history') {
                displayHistory();
            } else if (tabName === 'import') {
                displayCategories();
            }
        }

        // æ˜¾ç¤ºç»˜ç”»å†å²
        function displayHistory() {
            const grid = document.getElementById('history-grid');
            grid.innerHTML = '';

            if (drawingHistory.length === 0) {
                grid.innerHTML = '<p>æš‚æ— ç»˜ç”»è®°å½•ï¼Œå¿«å»ç”»ä¸€å¹…å§ï¼</p>';
                return;
            }

            // æ¸²æŸ“å†å²è®°å½•
            drawingHistory.forEach(drawing => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <img src="${drawing.imageData}" class="history-canvas" alt="${drawing.prediction}">
                    <div class="history-label">${drawing.prediction}</div>
                    <small>${new Date(drawing.timestamp).toLocaleString()}</small>
                `;
                // ç‚¹å‡»åŠ è½½å†å²ç»˜ç”»
                item.onclick = () => loadDrawing(drawing);
                grid.appendChild(item);
            });
        }

        // åŠ è½½å†å²ç»˜ç”»åˆ°ç”»å¸ƒ
        function loadDrawing(drawing) {
            // åˆ‡æ¢åˆ°ç»˜ç”»æ ‡ç­¾é¡µ
            switchTab('draw');
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            currentStrokes = JSON.parse(JSON.stringify(drawing.strokes));
            
            // é‡ç»˜ç”»ä½œ
            currentStrokes.forEach(stroke => {
                ctx.beginPath();
                ctx.moveTo(stroke[0][0], stroke[0][1]);
                stroke.forEach(point => {
                    ctx.lineTo(point[0], point[1]);
                });
                ctx.stroke();
            });

            // è‡ªåŠ¨è¯†åˆ«ï¼ˆå¯é€‰ï¼‰
            // recognize();
        }

        // æ¸…ç©ºå†å²è®°å½•
        function clearHistory() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç»˜ç”»è®°å½•å—ï¼Ÿæ¸…ç©ºåæ— æ³•æ¢å¤å“¦ï½')) {
                drawingHistory = [];
                localStorage.setItem('drawingHistory', JSON.stringify(drawingHistory));
                displayHistory();
            }
        }

        // å¯¼å‡ºå†å²è®°å½•
        function exportHistory() {
            if (drawingHistory.length === 0) {
                alert('æš‚æ— ç»˜ç”»è®°å½•å¯å¯¼å‡ºï¼');
                return;
            }
            const dataStr = JSON.stringify(drawingHistory, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `æˆ‘çš„ç®€ç¬”ç”»-${new Date().toLocaleDateString()}.json`;
            link.click();
            // é‡Šæ”¾URLå¯¹è±¡
            URL.revokeObjectURL(url);
        }

        // å¯¼å…¥Quick Drawæ•°æ®é›†
        function importDataset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const status = document.getElementById('import-status');
            status.className = 'status';
            status.textContent = 'æ­£åœ¨å¯¼å…¥æ•°æ®é›†...AIæ­£åœ¨å­¦ä¹ ä¸­ï½';
            status.style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    const lines = content.split('\n').filter(line => line.trim());
                    
                    let imported = 0;
                    const maxPerCategory = 50; // æ¯ä¸ªç±»åˆ«æœ€å¤šå¯¼å…¥50ä¸ªæ ·æœ¬ï¼ˆé˜²æ­¢å¡é¡¿ï¼‰
                    
                    // è§£ææ•°æ®é›†è¡Œ
                    lines.slice(0, maxPerCategory).forEach(line => {
                        try {
                            const data = JSON.parse(line);
                            if (data.word && data.drawing) {
                                // è½¬æ¢Quick Drawæ ¼å¼åˆ°æœ¬åœ°æ ¼å¼
                                const strokes = data.drawing.map(stroke => 
                                    stroke[0].map((x, i) => [
                                        x / 256 * canvas.width,  // ç¼©æ”¾åæ ‡åˆ°ç”»å¸ƒå°ºå¯¸
                                        stroke[1][i] / 256 * canvas.height
                                    ])
                                );
                                
                                // è®¡ç®—ç‰¹å¾
                                const features = {
                                    strokeCount: strokes.length,
                                    aspectRatio: 1,
                                    density: 0.1,
                                    width: canvas.width,
                                    height: canvas.height,
                                    totalPixels: 1000
                                };
                                
                                // æ·»åŠ åˆ°è®­ç»ƒæ•°æ®
                                addToTrainingData(data.word, { features, strokes });
                                imported++;
                            }
                        } catch (err) {
                            console.error('è§£ææ•°æ®è¡Œé”™è¯¯:', err);
                        }
                    });

                    // å¯¼å…¥æˆåŠŸæç¤º
                    status.className = 'status success';
                    status.textContent = `ğŸ‰ æˆåŠŸå¯¼å…¥ ${imported} ä¸ªç®€ç¬”ç”»æ ·æœ¬ï¼AIå­¦ä¼šäº†æ›´å¤šå›¾æ¡ˆï½`;
                    displayCategories();
                    
                    // 3ç§’åéšè—æç¤º
                    setTimeout(() => {
                        status.style.display = 'none';
                    }, 3000);
                } catch (error) {
                    status.className = 'status error';
                    status.textContent = 'âŒ å¯¼å…¥å¤±è´¥ï¼š' + error.message;
                }
            };

            reader.onerror = function() {
                status.className = 'status error';
                status.textContent = 'âŒ æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ï¼';
            };

            reader.readAsText(file);
        }

        // æ˜¾ç¤ºå·²åŠ è½½çš„ç±»åˆ«
        function displayCategories() {
            const container = document.getElementById('categories-list');
            const categories = Object.keys(trainingData);
            
            if (categories.length === 0) {
                container.innerHTML = '<p>AIè¿˜æ²¡å­¦ä¹ ä»»ä½•å›¾æ¡ˆï¼Œå¿«å»ç”»ç”»æˆ–å¯¼å…¥æ•°æ®é›†å§ï¼</p>';
                return;
            }

            // æ¸²æŸ“ç±»åˆ«æ ‡ç­¾
            container.innerHTML = categories.map(cat => 
                `<span>${cat} (${trainingData[cat].length}ä¸ªæ ·æœ¬)</span>`
            ).join('');
        }

        // é¡µé¢åˆå§‹åŒ–
        window.onload = function() {
            displayCategories();
            // é€‚é…ç”»å¸ƒå“åº”å¼
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        };

        // ç”»å¸ƒå“åº”å¼è°ƒæ•´
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = container.clientWidth - 40;
            if (maxWidth < canvas.width && maxWidth > 200) {
                canvas.style.width = maxWidth + 'px';
                canvas.style.height = maxWidth + 'px';
            } else {
                canvas.style.width = '400px';
                canvas.style.height = '400px';
            }
        }
    </script>
</body>
</html>